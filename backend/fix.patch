 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/dist/routes/appointments.js b/backend/dist/routes/appointments.js
index 7f8f22c9961331a6fd0bf5887d1f34f6b5d1507b..c0908b793d81e2915d7401a48211abd65907a0e8 100644
--- a/backend/dist/routes/appointments.js
+++ b/backend/dist/routes/appointments.js
@@ -8,67 +8,86 @@ const formatAppointment = (appointment, threadStatus, threadUpdatedAt) => {
     if (!appointment)
         return undefined;
     return {
         id: appointment.id,
         user_id: appointment.userId,
         thread_id: appointment.threadId,
         start: appointment.start,
         end: appointment.end,
         scheduled_for: appointment.start,
         created_at: appointment.createdAt,
         updated_at: threadUpdatedAt ?? appointment.createdAt,
         status: formatStatus(threadStatus),
     };
 };
 const formatUser = (user) => {
     if (!user)
         return undefined;
     const firstName = user.firstName ?? "";
     const lastName = user.lastName ?? "";
     const fullName = `${firstName} ${lastName}`.trim();
     return {
         id: user.id,
         name: fullName || undefined,
         email: user.email,
         phone: user.phone,
+        summary: user.summary,
     };
 };
 const formatMessageSender = (role) => {
     switch (role) {
         case "assistant":
             return "Assistant";
         case "user":
             return "User";
         case "system":
             return "System";
         default:
             return undefined;
     }
 };
 router.get("/", (_req, res) => {
     const appointments = (0, storage_1.getAppointments)().map((appointment) => {
         const thread = (0, storage_1.getThreadSummary)(appointment.threadId);
-        return formatAppointment(appointment, thread?.status, thread?.updatedAt);
+        const user = (0, storage_1.getUserProfile)(appointment.userId);
+        const formattedUser = formatUser(user);
+        const formattedAppointment = formatAppointment(appointment, thread?.status, thread?.updatedAt);
+        const reason = user?.summary;
+        return {
+            ...formattedAppointment,
+            user: formattedUser,
+            patient_name: formattedUser?.name,
+            patient_email: formattedUser?.email,
+            patient_phone: formattedUser?.phone,
+            reason,
+            summary: reason,
+        };
     });
     return res.json({ appointments });
 });
 router.get("/:id", (req, res) => {
     const appointment = (0, storage_1.findAppointmentById)(req.params.id);
     if (!appointment) {
         return res.status(404).json({ error: "Appointment not found" });
     }
     const thread = (0, storage_1.getThreadSummary)(appointment.threadId);
     const user = (0, storage_1.getUserProfile)(appointment.userId);
     const messages = (0, storage_1.getThreadMessagesWithIds)(appointment.threadId).map((message) => ({
         id: message.id,
         content: message.content,
         role: message.role,
         created_at: message.timestamp,
         sender: formatMessageSender(message.role),
     }));
+    const reason = user?.summary;
+    const formattedAppointment = formatAppointment(appointment, thread?.status, thread?.updatedAt);
     return res.json({
-        appointment: formatAppointment(appointment, thread?.status, thread?.updatedAt),
+        appointment: {
+            ...formattedAppointment,
+            reason,
+            summary: reason,
+        },
         user: formatUser(user),
         messages,
     });
 });
 exports.default = router;
diff --git a/backend/dist/services/agent.js b/backend/dist/services/agent.js
index befb4b6403d23e88fb9550ce04d3347c66047f40..5a03406574e254cf9d9c9bb42825a13e1b03f695 100644
--- a/backend/dist/services/agent.js
+++ b/backend/dist/services/agent.js
@@ -1,35 +1,41 @@
 "use strict";
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.hasRequiredFields = exports.runAgent = exports.FALLBACK_ASSISTANT_MESSAGE = exports.REQUIRED_USER_FIELDS = void 0;
 const openai_1 = __importDefault(require("openai"));
 const client = new openai_1.default({ apiKey: process.env.OPENAI_API_KEY });
-exports.REQUIRED_USER_FIELDS = ["firstName", "lastName", "email", "phone"];
-const getSystemInstructions = () => `You are a compassionate medical intake assistant. Use the conversation and known user fields to gather missing details politely. When a user provides their name, split it into firstName and lastName fields. Always respond with a single JSON object containing: \n- "assistantMessage": string for the patient,\n- "userUpdate": object with any new or updated user fields,\n- "hasAllRequiredFields": boolean true only when ${exports.REQUIRED_USER_FIELDS.join(", ")} are known,\n- "scheduleAppointment": boolean true when all required fields are collected and the user is ready to schedule.\nDo not include any extra keys.`;
+exports.REQUIRED_USER_FIELDS = [
+    "firstName",
+    "lastName",
+    "email",
+    "phone",
+    "summary",
+];
+const getSystemInstructions = () => `You are a compassionate medical intake assistant. Use the conversation and known user fields to gather missing details politely. When a user provides their name, split it into firstName and lastName fields. Be sure to capture a brief summary/reason for the appointment. Always respond with a single JSON object containing: \n- "assistantMessage": string for the patient,\n- "userUpdate": object with any new or updated user fields,\n- "hasAllRequiredFields": boolean true only when ${exports.REQUIRED_USER_FIELDS.join(", ")} are known,\n- "scheduleAppointment": boolean true when all required fields are collected and the user is ready to schedule.\nDo not include any extra keys.`;
 exports.FALLBACK_ASSISTANT_MESSAGE = "I'm sorry, but I couldn't process that right now. Could you please rephrase or provide the details again?";
 const formatKnownUserFields = (user) => {
     const entries = Object.entries(user)
         .filter(([key, value]) => key !== "id" && value !== undefined && value !== "")
         .map(([key, value]) => `- ${key}: ${String(value)}`);
     return entries.length ? entries.join("\n") : "No fields captured yet.";
 };
 const buildMessages = ({ user, recentMessages, newestMessage, }) => {
     const history = recentMessages.slice(-8).map((message) => ({
         role: message.role,
         content: message.content,
     }));
     const knownFields = formatKnownUserFields(user);
     return [
         {
             role: "system",
             content: `${getSystemInstructions()}\n\nKnown user fields:\n${knownFields}`,
         },
         ...history,
         {
             role: "user",
             content: newestMessage,
         },
     ];
 };
diff --git a/backend/dist/services/scheduler.js b/backend/dist/services/scheduler.js
index d348d64a69e48775d4a3f55ed7044cc82a7df7a8..8b6cf03c9743a4523139b61102d8744dfd926aec 100644
--- a/backend/dist/services/scheduler.js
+++ b/backend/dist/services/scheduler.js
@@ -1,87 +1,89 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.createAppointment = exports.getNextAvailableSlots = void 0;
 const storage_1 = require("./storage");
 const WORKING_HOURS_START = 10; // 10:00
 const WORKING_HOURS_END = 17; // 17:00
 const SLOT_DURATION_MINUTES = 30;
 const addMinutes = (date, minutes) => new Date(date.getTime() + minutes * 60000);
 const getDayStart = (date) => {
     const copy = new Date(date);
     copy.setHours(0, 0, 0, 0);
     return copy;
 };
-const hasConflict = (slotStart, appointments) => {
+const hasConflict = (slotStart, appointments, options) => {
     const slotEnd = addMinutes(slotStart, SLOT_DURATION_MINUTES);
     return appointments.some((appointment) => {
+        if (options?.ignoreThreadId && appointment.threadId === options.ignoreThreadId)
+            return false;
         const appointmentStart = new Date(appointment.start);
         const appointmentEnd = new Date(appointment.end);
         return slotStart < appointmentEnd && slotEnd > appointmentStart;
     });
 };
 const isWithinWorkingHours = (candidate) => {
     const hour = candidate.getHours();
     const minute = candidate.getMinutes();
     const afterStart = hour > WORKING_HOURS_START || (hour === WORKING_HOURS_START && minute >= 0);
     const beforeEnd = hour < WORKING_HOURS_END || (hour === WORKING_HOURS_END && minute === 0);
     return afterStart && beforeEnd;
 };
 const getNextAvailableSlots = (appointments, count = 3, referenceDate = new Date()) => {
     const slots = [];
     let cursor = new Date(referenceDate);
     // Round up to the next slot boundary
     const minutes = cursor.getMinutes();
     const offset = minutes % SLOT_DURATION_MINUTES;
     if (offset !== 0) {
         const adjustment = SLOT_DURATION_MINUTES - offset;
         cursor = addMinutes(cursor, adjustment);
     }
     let safety = 0;
     while (slots.length < count && safety < 60) {
         const dayStart = getDayStart(cursor);
         const dayWorkingStart = new Date(dayStart);
         dayWorkingStart.setHours(WORKING_HOURS_START, 0, 0, 0);
         const dayWorkingEnd = new Date(dayStart);
         dayWorkingEnd.setHours(WORKING_HOURS_END, 0, 0, 0);
         let slotCursor = new Date(Math.max(cursor.getTime(), dayWorkingStart.getTime()));
         while (slotCursor < dayWorkingEnd && slots.length < count) {
             if (isWithinWorkingHours(slotCursor) && !hasConflict(slotCursor, appointments)) {
                 slots.push(slotCursor.toISOString());
             }
             slotCursor = addMinutes(slotCursor, SLOT_DURATION_MINUTES);
         }
         cursor = addMinutes(dayWorkingEnd, SLOT_DURATION_MINUTES);
         safety += 1;
     }
     return slots.slice(0, count);
 };
 exports.getNextAvailableSlots = getNextAvailableSlots;
 const createAppointment = ({ user, threadId, slotStart, durationMinutes = SLOT_DURATION_MINUTES, }) => {
     const startDate = typeof slotStart === "string" ? new Date(slotStart) : slotStart;
     if (Number.isNaN(startDate.getTime())) {
         throw new Error("Invalid slot start time");
     }
-    if (hasConflict(startDate, (0, storage_1.getAppointments)())) {
+    if (hasConflict(startDate, (0, storage_1.getAppointments)(), { ignoreThreadId: threadId })) {
         throw new Error("Slot is no longer available");
     }
     const endDate = addMinutes(startDate, durationMinutes);
     const record = (0, storage_1.createAppointment)({
         userId: user.id,
         threadId,
         start: startDate.toISOString(),
         end: endDate.toISOString(),
     });
     // In a real system this would call an API. For now we log so we can trace the invocation.
     const appointmentContext = {
         firstName: user.firstName,
         lastName: user.lastName,
         fullName: `${user.firstName ?? ""} ${user.lastName ?? ""}`.trim(),
         email: user.email,
         phone: user.phone,
         start: record.start,
         end: record.end,
     };
     console.info("Created appointment:", appointmentContext);
     return record;
 };
 exports.createAppointment = createAppointment;
diff --git a/backend/dist/services/storage.js b/backend/dist/services/storage.js
index 12cc9fb5a0bafe58941c9c9126a54be8c711e2a9..792995a892ebc938286382bc8eb9449c6a5ea2d0 100644
--- a/backend/dist/services/storage.js
+++ b/backend/dist/services/storage.js
@@ -123,35 +123,48 @@ const getThreadWithMessages = (threadId) => {
         status: record.status,
     };
 };
 exports.getThreadWithMessages = getThreadWithMessages;
 const getThreadStatus = (threadId) => {
     const record = threads.get(threadId);
     if (!record) {
         throw new Error("Thread not found");
     }
     return record.status;
 };
 exports.getThreadStatus = getThreadStatus;
 const getThreadSummary = (threadId) => {
     const record = threads.get(threadId);
     if (!record)
         return undefined;
     return { ...record };
 };
 exports.getThreadSummary = getThreadSummary;
 const getAppointments = () => [...appointments];
 exports.getAppointments = getAppointments;
 const findAppointmentById = (appointmentId) => appointments.find((appointment) => appointment.id === appointmentId);
 exports.findAppointmentById = findAppointmentById;
 const createAppointment = (appointment) => {
     const now = new Date().toISOString();
-    const record = {
-        ...appointment,
-        id: (0, crypto_1.randomUUID)(),
-        createdAt: now,
-    };
-    appointments.push(record);
+    const existingIndex = appointments.findIndex((existing) => existing.threadId === appointment.threadId);
+    if (existingIndex !== -1) {
+        const existing = appointments[existingIndex];
+        const updated = {
+            ...existing,
+            ...appointment,
+            id: existing.id,
+            createdAt: existing.createdAt,
+        };
+        appointments.splice(existingIndex, 1, updated);
+    }
+    else {
+        const record = {
+            ...appointment,
+            id: (0, crypto_1.randomUUID)(),
+            createdAt: now,
+        };
+        appointments.push(record);
+    }
     touchThread(appointment.threadId);
-    return record;
+    return appointments.find((item) => item.threadId === appointment.threadId);
 };
 exports.createAppointment = createAppointment;
diff --git a/backend/services/scheduler.ts b/backend/services/scheduler.ts
index 97af8d1e4e1a9b3a76d0c22ecd5298d44138aa78..486143175cbed5f1a637f4c1b6d151dc92cdc8ac 100644
--- a/backend/services/scheduler.ts
+++ b/backend/services/scheduler.ts
@@ -1,48 +1,55 @@
 import { Appointment, UserProfile } from "../types";
 import {
   createAppointment as persistAppointment,
   getAppointments,
 } from "./storage";
 
 const WORKING_HOURS_START = 10; // 10:00
 const WORKING_HOURS_END = 17; // 17:00
 const SLOT_DURATION_MINUTES = 30;
 
 const addMinutes = (date: Date, minutes: number): Date =>
   new Date(date.getTime() + minutes * 60_000);
 
 const getDayStart = (date: Date): Date => {
   const copy = new Date(date);
   copy.setHours(0, 0, 0, 0);
   return copy;
 };
 
-const hasConflict = (slotStart: Date, appointments: Appointment[]): boolean => {
+const hasConflict = (
+  slotStart: Date,
+  appointments: Appointment[],
+  options?: { ignoreThreadId?: string }
+): boolean => {
   const slotEnd = addMinutes(slotStart, SLOT_DURATION_MINUTES);
 
   return appointments.some((appointment) => {
+    if (options?.ignoreThreadId && appointment.threadId === options.ignoreThreadId)
+      return false;
+
     const appointmentStart = new Date(appointment.start);
     const appointmentEnd = new Date(appointment.end);
 
     return slotStart < appointmentEnd && slotEnd > appointmentStart;
   });
 };
 
 const isWithinWorkingHours = (candidate: Date): boolean => {
   const hour = candidate.getHours();
   const minute = candidate.getMinutes();
   const afterStart = hour > WORKING_HOURS_START || (hour === WORKING_HOURS_START && minute >= 0);
   const beforeEnd = hour < WORKING_HOURS_END || (hour === WORKING_HOURS_END && minute === 0);
   return afterStart && beforeEnd;
 };
 
 export const getNextAvailableSlots = (
   appointments: Appointment[],
   count = 3,
   referenceDate: Date = new Date()
 ): string[] => {
   const slots: string[] = [];
   let cursor = new Date(referenceDate);
 
   // Round up to the next slot boundary
   const minutes = cursor.getMinutes();
@@ -71,51 +78,51 @@ export const getNextAvailableSlots = (
     }
 
     cursor = addMinutes(dayWorkingEnd, SLOT_DURATION_MINUTES);
     safety += 1;
   }
 
   return slots.slice(0, count);
 };
 
 export const createAppointment = ({
   user,
   threadId,
   slotStart,
   durationMinutes = SLOT_DURATION_MINUTES,
 }: {
   user: UserProfile;
   threadId: string;
   slotStart: Date | string;
   durationMinutes?: number;
 }): Appointment => {
   const startDate = typeof slotStart === "string" ? new Date(slotStart) : slotStart;
   if (Number.isNaN(startDate.getTime())) {
     throw new Error("Invalid slot start time");
   }
 
-  if (hasConflict(startDate, getAppointments())) {
+  if (hasConflict(startDate, getAppointments(), { ignoreThreadId: threadId })) {
     throw new Error("Slot is no longer available");
   }
 
   const endDate = addMinutes(startDate, durationMinutes);
 
   const record = persistAppointment({
     userId: user.id,
     threadId,
     start: startDate.toISOString(),
     end: endDate.toISOString(),
   });
 
   // In a real system this would call an API. For now we log so we can trace the invocation.
   const appointmentContext = {
     firstName: user.firstName,
     lastName: user.lastName,
     fullName: `${user.firstName ?? ""} ${user.lastName ?? ""}`.trim(),
     email: user.email,
     phone: user.phone,
     start: record.start,
     end: record.end,
   };
 
   console.info("Created appointment:", appointmentContext);
   return record;
diff --git a/backend/services/storage.ts b/backend/services/storage.ts
index ca9f9cfef2961ff51d059cabdc7e650574d322d0..9737c31d6ac8740127eb0f49b00afb223cb27498 100644
--- a/backend/services/storage.ts
+++ b/backend/services/storage.ts
@@ -194,35 +194,50 @@ export const getThreadStatus = (threadId: string): ThreadStatus => {
 };
 
 export const getThreadSummary = (
   threadId: string
 ): (ThreadRecord & { userId: string }) | undefined => {
   const record = threads.get(threadId);
   if (!record) return undefined;
 
   return { ...record };
 };
 
 export const getAppointments = (): Appointment[] => [...appointments];
 
 export const findAppointmentById = (
   appointmentId: string
 ): Appointment | undefined =>
   appointments.find((appointment) => appointment.id === appointmentId);
 
 export const createAppointment = (appointment: {
   userId: string;
   threadId: string;
   start: string;
   end: string;
 }): Appointment => {
   const now = new Date().toISOString();
-  const record: Appointment = {
-    ...appointment,
-    id: randomUUID(),
-    createdAt: now,
-  };
+  const existingIndex = appointments.findIndex(
+    (existing) => existing.threadId === appointment.threadId
+  );
+
+  if (existingIndex !== -1) {
+    const existing = appointments[existingIndex];
+    const updated: Appointment = {
+      ...existing,
+      ...appointment,
+      id: existing.id,
+      createdAt: existing.createdAt,
+    };
+    appointments.splice(existingIndex, 1, updated);
+  } else {
+    const record: Appointment = {
+      ...appointment,
+      id: randomUUID(),
+      createdAt: now,
+    };
+    appointments.push(record);
+  }
 
-  appointments.push(record);
   touchThread(appointment.threadId);
-  return record;
+  return appointments.find((item) => item.threadId === appointment.threadId)!;
 };
 
EOF
)